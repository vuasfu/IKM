Калькулятор выражений с операциями min и max

Постановка задачи
Используя структуру стека, вычислить выражение, содержащее две операции: поиск минимума (обозначается m(,)) и поиск максимума (обозначается М(,)). Операции могут быть вложенными, например, M(15, m(16,8)) (в данном выражении ищем минимум из 16 и 8, а потом ищем максимум от результата m(16,8) и 15, ответ 15). В качестве аргументов могут использоваться только целые положительные числа.

Ключевые требования:
Поддержка вложенных выражений (например, M(5, m(3, 4)))
Обработка только целых положительных чисел
Полная проверка корректности входных данных
Интерактивный интерфейс с возможностью выхода
Автоматическое удаление пробелов из выражений

Основная структура: Стек на односвязном списке (класс Stack)

Обоснование выбора односвязного списка для стека:
1. Эффективность по памяти: Каждый узел хранит только значение и один указатель
2. Быстрые операции: Все операции со стеком (push/pop/peek) выполняются за O(1)
3. Динамическое расширение: Нет ограничений на размер стека
4. Идеальное соответствие принципу LIFO: Все операции выполняются с вершиной

Архитектура стека:
StackNode: класс узла (value, next)
Stack: основной класс стека (top, size)
Операции: push(), pop(), peek(), is_empty(), get_size()

Алгоритм решения
Основные этапы:
1. Инициализация:
Создание пустого стека
Загрузка словаря операций {'m': min, 'M': max}

2. Предварительная обработка:
Удаление всех пробелов из выражения
Проверка на пустое выражение

3. Парсинг выражения:
for char in expression:
    if char is digit:
        # Собираем полное число
    elif char is operation:
        stack.push(char)
    elif char is '(':
        stack.push(char)
    elif char is ')':
        # Вычисляем операцию

4. Вычисление операции (apply_operation):
Извлекаем второй аргумент
Извлекаем первый аргумент
Проверяем открывающую скобку
Извлекаем операцию
Применяем операцию и возвращаем результат

5. Завершение:
В стеке должен остаться ровно 1 элемент (результат)
Иначе - ошибка формата

Классы и их ответственность

1. Stack (реализация на односвязном списке):
Поля: top (указатель на вершину), size (счетчик элементов)
Методы: 
push(item) - добавление элемента
pop() - извлечение элемента
peek() - просмотр вершины
is_empty() - проверка пустоты
get_size() - получение размера

2. ExpressionCalculator:
Поля: operations (словарь операций)
Методы:
calculate(expression) - основной алгоритм вычисления
apply_operation(stack) - применение операции к аргументам из стека

Особенности реализации

Парсинг чисел:
while i < n and expression[i].isdigit():
    num_str.append(expression[i])
    i += 1
stack.push(int(''.join(num_str)))
Почему так? - Для поддержки многоразрядных чисел (например, 123)

Обработка скобок:
elif char == ')':
    result = self.apply_operation(stack)
    stack.push(result)
Почему отдельный метод? - Для изоляции сложной логики вычислений

Обработка пробелов и разделителей:
expression = expression.replace(' ', '')  # удаление всех пробелов
Почему так? - Для удобства пользователя и упрощения парсинга

Принципы ООП в реализации

1. Инкапсуляция:
Четкое разделение ответственности между классами
Публичный интерфейс скрывает внутреннюю реализацию

2. Полиморфизм:
Проявляется в словаре операций: {'m': min, 'M': max}
Один интерфейс для разных операций

3. Согласованность имен:
Все методы и атрибуты имеют публичные имена
Единый стиль именования во всем коде

Обработка ошибок

Типы обрабатываемых ошибок:
Несбалансированные скобки
Неправильное количество аргументов
Неизвестные операции
Недопустимые символы
Пустые выражения
Неполные выражения

Сообщения об ошибках:
Четкие и информативные сообщения
Подсказки по правильному формату ввода

Примеры использования

Корректные выражения:
m(5,10) → 5
M(15,m(16,8)) → 15
m(M(2,5),M(3,8)) → 5
m ( 5 , 10 ) → 5 (пробелы автоматически удаляются)

Ошибочные выражения:
m(5,) → Ошибка: Недостаточно аргументов
M(,10) → Ошибка: Недостаточно аргументов
k(1,2) → Ошибка: Недопустимый символ
m(5,10 → Ошибка: Несбалансированные скобки
